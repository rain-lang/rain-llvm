/*!
The data-structures necessary for `rain` code generation
*/
use super::repr::*;
use crate::error::Error;
use arena::Arena;
use either::Either;
use fxhash::FxHashMap as HashMap;
use hayami::{SymbolMap, local::SymbolTable};
use inkwell::basic_block::BasicBlock;
use inkwell::builder::Builder;
use inkwell::context::Context;
use inkwell::module::Module;
use inkwell::values::FunctionValue;
use rain_ir::region::{Region, Regional};
use rain_ir::value::{TypeId, ValId, ValueEnum};

mod finite;
mod function;
mod logical;
mod shim;
mod tuple;

// NOTE: these modules are public to avoid unused code errors
pub mod arena;

/**
A `rain` code generation context for a given module.

Code generation for most `rain` values should be implemented as methods modifying this struct, which can potentially then
be accessed asynchronously by a single-threaded executor for an `async` compilation model. Thought should be given to
potential generalizations to a multi-threaded compilation model, with separate LLVM modules being generated by each thread
(think in terms of `rustc`s codegen units), but that should come later.
*/
#[derive(Debug)]
pub struct Codegen<'ctx> {
    /// Global rain values
    globals: HashMap<ValId, Val<'ctx>>,
    /// Indices and basic blocks for LLVM-function specific value symbol tables
    local_ixs: HashMap<FunctionValue<'ctx>, (usize, Option<BasicBlock<'ctx>>)>,
    /// Arena for symbol tables
    local_arena: Arena<'ctx>,
    /// Current local scope
    curr_ix: usize,
    /// The current region being inlined
    curr_region: Option<Region>,
    /// The current function being compiled, if any
    curr: Option<FunctionValue<'ctx>>,
    /// Type representations
    reprs: HashMap<TypeId, Repr<'ctx>>,
    /// Function name counter.
    counter: usize,
    /// The LLVM module to which these values are being added
    module: Module<'ctx>,
    /// The IR builder for this codegen context
    builder: Builder<'ctx>,
    /// The enclosing context of this codegen context
    context: &'ctx Context,
}

impl<'ctx> Codegen<'ctx> {
    /// Create a new, empty code-generation context bound to a given LLVM `context` and `module`
    pub fn new(context: &'ctx Context, module: Module<'ctx>) -> Codegen<'ctx> {
        Codegen {
            globals: HashMap::default(),
            local_ixs: HashMap::default(),
            local_arena: Arena::new(),
            curr_ix: 0,
            curr_region: None,
            curr: None,
            reprs: HashMap::default(),
            counter: 0,
            module,
            builder: context.create_builder(),
            context,
        }
    }

    /// Get the global compiled `rain` values
    ///
    /// See the documentation for the `globals` private member of `Codegen` for more information.
    #[inline]
    pub fn globals(&self) -> &HashMap<ValId, Val<'ctx>> {
        &self.globals
    }

    /// Get the compiled representations in this context
    ///
    /// See the documentation for the `reprs` private member of `Codegen` for more information.
    #[inline]
    pub fn reprs(&self) -> &HashMap<TypeId, Repr<'ctx>> {
        &self.reprs
    }
    /// Get the representation for a given type, if any
    pub fn repr(&mut self, t: &TypeId) -> Result<Repr<'ctx>, Error> {
        // Special cases
        match t.as_enum() {
            ValueEnum::BoolTy(_) => return Ok(Repr::Type(self.context.bool_type().into())),
            _ => {}
        }
        // Cached case
        if let Some(repr) = self.reprs.get(t) {
            return Ok(repr.clone());
        }
        // General case
        let r = match t.as_enum() {
            ValueEnum::Finite(f) => self.repr_finite(f),
            ValueEnum::Product(p) => self.repr_product(p)?,
            ValueEnum::BoolTy(_) => unreachable!(),
            _ => unimplemented!("Representation for rain type {} is not implemented", t),
        };
        let old = self.reprs.insert(t.clone(), r.clone());
        // We just checked above that the type has no representation!
        // TODO: think about this: perhaps compiling the type has led to it getting a representation...
        // consider an in-progress compilation map to avoid infinite loops...
        // No wait, this should be prevented by the DAG-property of the `rain` graph...
        debug_assert_eq!(old, None);
        Ok(r)
    }
    /// Build a given value
    pub fn build(&mut self, v: &ValId) -> Result<Val<'ctx>, Error> {
        let depth = v.depth();
        if depth == 0 {
            if let Some(val) = self.globals().get(v) {
                return Ok(val.clone());
            }
        } else {
            if let Some(this_table) = self.local_arena.get_mut(self.curr_ix) {
                if let Some(val) = this_table.get(v) {
                    return Ok(val.clone());
                }
            } else {
                panic!(
                    "A symbol table should be already pushed when compiling a value in function"
                );
            }
        }

        let val = match v.as_enum() {
            ValueEnum::Bool(b) => self.build_bool(*b).into(),
            ValueEnum::Lambda(l) => self.build_lambda(l)?,
            ValueEnum::Logical(l) => self.build_logical(l).into(),
            ValueEnum::Sexpr(s) => self.build_sexpr(s)?,
            ValueEnum::Tuple(t) => self.build_tuple(t)?,
            ValueEnum::Product(p) => self.build_product(p)?,
            ValueEnum::Parameter(_) => panic!("Unregistered parameter {}, depth = {}!", v, depth),
            ValueEnum::Finite(f) => self.build_finite(f),
            ValueEnum::Index(i) => self.build_index(i),
            _ => unimplemented!("Building value {}", v),
        };

        if depth == 0 {
            self.globals.insert(v.clone(), val.clone());
        } else {
            if let Some(this_table) = self.local_arena.get_mut(self.curr_ix) {
                this_table.insert(v.clone(), val.clone());
            } else {
                panic!(
                    "A symbol table should be already pushed when compiling a value in function"
                );
            }
        }
        Ok(val)
    }
}
